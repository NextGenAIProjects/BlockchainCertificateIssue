from flask import Flask, render_template, request, jsonify
from web3 import Web3
import json
from requests.adapters import HTTPAdapter
from requests.sessions import Session
from eth_utils import to_checksum_address # This fixes the 'undefined' error

# Create a custom session to prevent "Connection Refused" on retries
session = Session()
session.mount('http://', HTTPAdapter(max_retries=5))

app = Flask(__name__)

# Load config generated by contract_deploy.py
with open("config.json", "r") as f:
    config = json.load(f)

w3 = Web3(Web3.HTTPProvider("http://127.0.0.1:7545",request_kwargs={'timeout': 60}, session=session))
contract = w3.eth.contract(address=config["contract_address"], abi=config["abi"])
# ... rest of your Flask routes ...

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/api/verify', methods=['POST'])
def verify():
    cert_id = request.json.get('cert_id')
    try:
        # Calling the blockchain view function
        name, course, is_valid = contract.functions.verifyCertificate(cert_id).call()
        
        if is_valid:
            return jsonify({"status": "verified", "name": name, "course": course})
        else:
            return jsonify({"status": "not_found"}), 404
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/admin')
def admin_page():
    return render_template('admin.html')

@app.route('/api/issue', methods=['POST'])
def issue_cert():
    data = request.json
    cert_id = data.get('cert_id')
    name = data.get('name')
    course = data.get('course') 
    recipient_raw = data.get('recipient_address', '').strip() # Remove spaces
        
    try:
        # 1. Validate format and fix casing
        if not Web3.is_address(recipient_raw):
            return jsonify({"status": "error", "message": "Invalid Ethereum Address format!"}), 400
        
        # Convert to official Checksum format (Fixes casing issues)
        recipient_addr = Web3.to_checksum_address(recipient_raw)

        # 2. Verify address exists in your current Ganache session
        ganache_accounts = [Web3.to_checksum_address(acc) for acc in w3.eth.accounts]
        if recipient_addr not in ganache_accounts:
            return jsonify({"status": "error", "message": "Address not found in Ganache! Please use an address from your Ganache list."}), 400
        # Use the first account from Ganache as the Admin
        admin_account = w3.eth.accounts[0]
        
        # Build transaction
        tx_hash = contract.functions.issueCertificate(
            cert_id, name, course
        ).transact({'from': admin_account})
        
        # Wait for confirmation
        receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        
        return jsonify({
            "status": "success", 
            "tx_hash": receipt.transactionHash.hex()
        })
    except Exception as e:
        # Catch the "Certificate already exists" error from Solidity
        error_msg = str(e)
        if "already exists" in error_msg:
            return jsonify({"status": "error", "message": "Certificate ID already exists!"}), 400
        return jsonify({"status": "error", "message": error_msg}), 500

@app.route('/api/history', methods=['GET'])
def get_history():
    try:
        # Fetch all "CertificateIssued" events from block 0 to latest
        event_filter = contract.events.CertificateIssued.create_filter(from_block=0)
        events = event_filter.get_all_entries()
        
        history = []
        for event in events:
            history.append({
                "cert_id": event.args.certId,
                "name": event.args.candidateName,
                "course": event.args.courseName,
                "block": event.blockNumber
            })
        return jsonify(history)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(port=5000, debug=True)